#pc端商城
==
    pc商城基于后台leval框架和前端jquery.js完成
    前端主要插件有：swiper2.7.6，jquery.validate.js，jquery.form,js，layui.js。
    商品图区 比例：尽量1/1
    ad区广告图片 比例： 0.6/1
    地址栏中id均为商品id;pid表示货品id;bid表示品牌id;cid表示分类id;oid表示订单id;
    rid表示售后单id;gid表示售后商品id;s代表订单状态,h表示公告或帮助,t表示团购或抢购;
    aid表示文章id;
    js请求成功回调中声明的str，len变量只用作处理数据使用，并无特定含义
    商品数量只能为数字并且第一位不能为0
pc商城前端项目框架结构
--
    ->css:css文件
    ->html:html文件
    ->imgs:imgs文件
    ->js:js文件（包括全局js和自定义插件js）
    ->layui:layui插件
    ->static:静态资源文件（引入插件js和css）
弹出组件_msg()说明
--
    参数：option为参数对象{
        title：参数为提示标题，只能为两个字，
        msg：参数为提示内容，尽量简洁明了(12个字符以内)，
        time：参数为自动关闭时间，默认为3秒
        其他参数：暂未扩展，}
    样式表写在util.css公共样式表内
##goods.html => 商品页
--
    声明： product_id用来存储货号，layer为弹出容器，evaluate为商品评价参数。
    流程： 加入购物车和立即购买会判断是否登陆状态，未登录会弹出登陆。登陆完毕后可以重新选择加入购物车或立即购买。
          立即购买和加入购物车会判断是否选取规格，如为选取则提示选取规格。点击选择规格时会监视规格是否选择完整，
          如果选择完整会请求此规格的货号，此时点击加入购物车或立即购买可以通过请求，进入下一个流程。

cart.html => 购物车页
-----------------
    购物车页面会在进入页面判断是否登陆然后重定向
    声明： product_id 用来存储货号，num用来接收数量
    流程：购物车请求接到数据后，会在包裹数据的<li></li>标签上加入'data-id'属性
    来记录此条数据商品id，加入'data-pid'属性记录此条数据货品id。然后开启
    购物车数量加减功能，读取此条数据的li标签携带的'data-id','data-pid'
    参数发送新的购物车请求，并将货号id和数量发送，请求回来的数据重新填充视图
    模版。因此会丢失每条数据的checkbox选中状态，购物车的总价也无法实时计算。
    开启每条数据的checkbox处理。点击复选框时会将checkbox的状态作为value，
    从此条数据的li标签读取的'data-pid'值作为key，作为一个名为'cartCheck'
    的对象的一个键值对存储在浏览器session中，并将此checkbox的状态值添加为
    此条数据的li标签的'data-act'的属性值来实时记录选中状态。请求回来的数据
    会读取所存'cartCheck'会话存储并根据'pid'将其中的状态值与对应的数据赋值
    来记录过去时的选中状态。购物车请求完毕，加，减，选中都会调用总价计算函数。
    总价计算函数读取每条数据的li标签上的'data-act'属性值来跟踪选中状态的li
    标签，并获取其内的'小计'参数想加计算得到总价。
    删除和移入收藏：共用一个接口，因此'移删函数'设置三个参数，第一个为货号，
    第二个为操作类型，第三个为商品id。
    去结算：会遍历所有购物车的li盒子，找出'data-act'属性为true的li读取其上
    的'data-id'为商品id，'data-pid'为货品id，其内的储存数量的input的val
    为数量成为一组商品object并push进param数组收集完毕后作为数据发送给订单准
    备接口，请求成功后跳转确认订单页进入下一个流程。
search.html => 列表页
--
article.html => 文章页
--
confirm-order => 确认订单页
--
    确认订单页会在进入页面时检查是否开启了发票功能来安排视图。
    声明：shop 用来储存生成发票、税率等配置项，invoice来监视是否开启了发票功能，
         YHQ用来储存优惠券的使用信息和是否使用积分（id，面额，jf），invoice用
         来存储发票数据，具体参数见代码，addres用来存储收货人信息，order存储订
         单提交成功后返回的信息，pay存储支付方式id,prom_orders储存订单数据盒子
         settlement储存所有与计算应付有关的数据并集中计算，order接收订单提交后
         的返回信息。
    流程：请求订单数据成功后会填充页面视图。当不存在收货地址时会弹出添加收货地址
    窗口，保存后自动成为默认地址并重新请求订单数据。'全部收货地址'按钮可以掉起窗
    口请求全部地址列表，选择后会发送地址id并重新请求订单数据。'编辑'按钮可以弹出
    窗口编辑当前地址信息，保存后会重新保存地址并发送id重新请求订单数据。确认订单
    页只显示一条地址信息。
        编辑地址会请求地址信息并弹出视图，并调用getRegion（）函数请求省市县，函数设置
    两个参数，val表示0=>省，1=>市,2=>县。id为上级地区id。请求成功后会调用disposeRegion（）
    函数吧获取到的内容插入dom，接收两个参数，val区分省市县，data为获取内容。
         发票信息会计算并显示税金。
         结算数据会计算此订单使用积分能抵扣金额，并等待选择使用。
         选择优惠券、积分、发票、活动都会使应付价格变动，集中在computePayable()
    函数计算。
         点击提交订单时会执行'validateOrder()'函数验证地址和处理发票信息的数据
    只对地址做必须验证。通过后会调用'submitOrder()'函数提交订单，如果成功会储存
    返回的订单信息并调用'getPayWhat()'函数获取支付方式，选择支付方式时会将存在li
    盒子上的'data-id'的值赋给'pay'变量。此时关闭支付窗或取消按钮，页面指向待付款
    订单列表页，选择支付方式并输入密码后确定掉用'payFor()'函数发起请求，成功后指向
    待收货列表页进入下一流程。

footprint.html => 我的足迹
--

